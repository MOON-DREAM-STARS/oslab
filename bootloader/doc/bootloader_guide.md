# Bootloader 统一实现指南

**最后更新**: 2025年9月3日

## 1. 概述与架构

### 1.1. 项目目标

为 xv6 操作系统实现一个完整的、模仿真实硬件启动流程的两阶段 Bootloader。取代 QEMU 使用 `-kernel` 参数直接加载内核的方式，从而深入学习底层系统引导机制。

### 1.2. 整体架构

启动流程分为三个主要阶段：

```
+-----------------+      +----------------------+      +--------------------+
|  Stage 1        |  ->  |  Stage 2             |  ->  |  Kernel            |
|  (Boot Sector)  |      |  (Bootloader Main)   |      |  (xv6)             |
+-----------------+      +----------------------+      +--------------------+
- 512字节限制        - C语言实现, 32KB限制      - ELF格式
- 汇编实现           - VirtIO驱动, 内存管理     - 从磁盘加载
- 加载Stage 2       - ELF解析, 加载内核       - 接收引导参数
```

### 1.3. 内存与磁盘布局

#### 内存映射
```
0x10000000: UART设备
0x80000000: Bootloader 加载区
0x80001000: 内核加载区
0x80200000: 可用内存池
```

#### 磁盘镜像结构
```
├── 扇区 0:       Boot Sector (Stage 1)
├── 扇区 1-63:    Bootloader (Stage 2)
├── 扇区 64-2047: 内核 ELF 文件
└── 扇区 2048+:   文件系统
```

## 2. 快速开始

这个最小步骤让你能快速验证基础环境。

1.  **构建 Bootloader**:
    ```bash
    make -C bootloader
    ```

2.  **创建引导磁盘**:
    ```bash
    # 该命令会整合 stage1, stage2, kernel 和 fs.img
    make bootdisk_stage3.img
    ```

3.  **运行 QEMU**:
    ```bash
    # 使用整合测试脚本
    ./bootloader/test/test_stage3_complete.sh
    ```
    如果一切正常，你将看到 Bootloader 的输出，并最终进入 xv6 的 shell。

## 3. Stage 1: 基础引导扇区

**目标**: 在512字节的限制内，完成硬件初始化，并从磁盘加载 Stage 2。

### 实现成果
- **大小**: 168字节，远低于512字节的限制。
- **语言**: 纯 RISC-V 汇编。
- **功能**:
    1.  设置初始栈指针。
    2.  初始化 UART，用于后续输出。
    3.  调用 VirtIO 驱动从磁盘的第1个扇区开始读取 Stage 2 的内容。
    4.  跳转到 Stage 2 的入口点（`0x80001000`）。

## 4. Stage 2: 核心引导服务

**目标**: 实现一个功能完备的引导加载器，具备驱动、内存管理和内核加载能力。

### 4.1. VirtIO 块设备驱动
- **设备发现**: 实现了对 `0x10001000` 到 `0x10008000` 地址范围的自动扫描，以查找 VirtIO 块设备。
- **版本兼容**: 兼容 VirtIO 版本1和版本2的设备。
- **状态协商**: 严格遵循 `ACKNOWLEDGE -> DRIVER -> FEATURES_OK` 的流程，确保设备正确初始化。
- **队列管理**: 设置了大小为 1024 的描述符表（`desc`）、可用环（`avail`）和已用环（`used`），并为它们分配了对齐的内存页面。

### 4.2. 内存管理
- **页分配器**: 提供一个简单的 `boot_alloc_page()` 函数，用于分配4KB对齐的内存页面。
- **内存布局**: Stage 2 自身加载于 `0x80001000`，其堆内存从 `0x80010000` 开始，用于动态分配 VirtIO 队列和内核加载缓冲区。

### 4.3. 调试与错误处理
- **详细输出**: 在关键步骤（如设备发现、状态改变、内存分配）都有详细的 UART 输出。
- **统一错误码**: 定义了 `BOOT_SUCCESS`, `BOOT_ERROR_MEMORY`, `BOOT_ERROR_DISK` 等错误码，便于问题定位。

## 5. Stage 3: ELF 加载与内核启动

**目标**: 解析 xv6 内核的 ELF 文件，将其正确加载到内存，并传递控制权。

### 5.1. ELF 解析器 (`elf_loader.c`)
- **ELF头部解析**: 能够读取 ELF Header，验证其魔数 (`0x7fELF`)，并获取程序入口点 (`e_entry`) 和程序头表 (`e_phoff`, `e_phnum`) 的信息。
- **程序头加载**: 遍历程序头表，识别所有 `PT_LOAD` 类型的段。
- **段加载**: 对于每个可加载段，从磁盘的指定偏移 (`p_offset`) 读取 `p_filesz` 大小的数据，并将其加载到物理地址 `p_paddr`。
- **BSS段清零**: 如果段的内存大小 `p_memsz` 大于文件大小 `p_filesz`，会自动将多出的部分（BSS段）清零。

### 5.2. 内核参数传递
- **RISC-V 标准**: 遵循 RISC-V SBI (Supervisor Binary Interface) 的引导约定。
- **寄存器传递**:
    - `a0`: 传递当前的 `hart_id` (处理器核心ID)。
    - `a1`: 传递 `boot_info` 结构体的指针。
- **`boot_info` 结构**: 一个包含了魔数、内存布局、内核位置、设备树地址等关键信息的数据结构，供内核使用。

### 5.3. 设备树 (Device Tree)
- **动态生成**: 根据硬件检测（目前主要是 QEMU virt 平台）的结果，动态生成一个简化的设备树。
- **核心节点**: 包含 `memory`、`cpu`、`uart`、`virtio` 四个关键节点，向内核描述基础硬件环境。

### 5.4. 最终跳转
在所有准备工作完成后，Bootloader 会执行 `fence.i` 指令清空指令缓存，然后通过 `jr` 指令精确地跳转到内核的入口点，将系统控制权交给内核。

## 6. 构建与测试

### 6.1. 核心构建命令
- `make stage2.bin`: 构建 Stage 1 和 Stage 2。
- `make bootdisk_stage3.img`: 创建包含所有部分的完整引导磁盘。

### 6.2. 测试脚本
- `test/test_stage3_simple.sh`: 快速功能验证。
- `test/test_stage3_complete.sh`: 完整的端到端启动测试，验证 xv6 shell 是否成功运行。
